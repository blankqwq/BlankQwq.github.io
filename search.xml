<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贝叶斯定理]]></title>
    <url>%2F2019%2F12%2F30%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[公式论证 1）要求解的问题：女神喜欢你，记为A事件 2）已知条件：女神经常冲你笑，记为B事件 所以说，P(A|B) 是女神经常冲你笑这个事件(B)发生后，女神喜欢你（A）的概率。 在B的情况下发生A的概率 我 们把P(A)称为&apos;先验概率&apos;（Prior probability）， 即在不知道B事件的前提下 我们对A事件概率的一个主观判断。 这个例子里就是在不知道女神经常对你笑的前提下 来主观判断出女 神喜欢一个人的概率 这里我们假设是50% 也就是不能喜欢你 可能不喜欢还你的概率都是一半。 P(B|A)/P(B)称为&apos;可能性函数&apos;（Likelyhood）， 这是一个调整因子，即新信息B带来的调整， 作用是使得先验概率更接近真实概率。 P(A|B)称为&apos;后验概率&apos;（Posterior probability），即在B事件发生之后， 我们对A事件概率的重新评估 这个例子里就是在女神冲你笑后 对女神喜欢你的概率重新预测。 预测结果 女神经常冲你笑，喜欢上你的概率是75%。 女神经常冲你笑这个新信息的推断能力很强， 将50%的&apos;先验概率&apos;一下子提高到了75%的&apos;后验概率&apos;。 朴素贝叶斯: p(A|B) =p(A) * p(B|A)/p(B) 条件独立形式 相关性表示 如果&apos;可能性函数&apos;P(B|A)/P(B)&gt;1， 意味着&apos;先验概率&apos;被增强，事件A的发生的可能性变大； 如果&apos;可能性函数&apos;=1， 意味着B事件无助于判断事件A的可能性； 如果&quot;可能性函数&quot;&lt;1， 意味着&quot;先验概率&quot;被削弱 事件A的可能性变小 多概率事件表示 X = x1 + x2 =1 比如:从盒子1中中间或者从盒子2中中奖 x1 = x2 =0.5 B:中奖事件 p(B) = p(x1)*p(B|x1) + p(x2) * p(B|x2) P(x1|B) = p(B) * p(B|x1)/p(x1) 朴素贝叶斯定理 与 大脑决策过程对比 朴素贝叶斯 1234graph LR先验概率--&gt;贝叶斯定理可能性函数--&gt;贝叶斯定理贝叶斯定理--&gt;a(后验概率) 大脑决策 1234graph LR主关判断--&gt;大脑收集新信息--&gt;大脑大脑--&gt;a(优化判断)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个编译器（C语言子集）]]></title>
    <url>%2F2019%2F11%2F02%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AD%90%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C语言运行流程//静态链接编译hello.c &gt; gcc hello.c -o hello -static //查看详情 &gt; gcc hello.c -o hello -static --verbose 可以看出编译背后使用了cc1，as，collect2 三个命令 cc1 是gcc的编译器 产生=》 hello.s as 是汇编器命令 =&gt; hello.o collect2 是链接命令 =&gt; 可执行文件 编译 gcc -E hello.c -o hello.i //预编译阶段 gcc -S hello.i -o hello.s //编译为汇编文件(AT&amp;T格式) 汇编(预编译会引入elf.h) gcc -c hello.s -o hello.o readlef -a hello.h //查看elf文件内容与结构 生成ELF文件 gcc hello.o -o hello 编译过程 编译的过程就是翻译的过程 1.单词分析-&gt;n,adj, 2.分析结构-&gt;主,谓,宾 3.语法分析-&gt;xx从句 4.翻译结果 编译器流程 1.词法分析 2.语法分析 3.语义分析 4.中间代码生成器 5.机器无关代码优化器 6.目标代码生成器 7.机器相关代码优化器 词法分析器从左往右，逐行扫描，确认每个单词的含义,类型 token:&lt;种别码，属性值&gt; 文法： G=({+,-,*,(,)}.{E},P,E) P={ E-&gt;E+E E-&gt;E*E E-&gt;(E) } G: E-&gt;E+E E-&gt;E*E E-&gt;(E) 以上可以表示无穷个句子 所以，文法解决了无穷语言的有穷的表答问题 文法定义 单元流 有穷变换机 ELF是什么?//todo 其他中间文件有穷变换机]]></content>
      <categories>
        <category>编译器</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select和epoll的笔记]]></title>
    <url>%2F2019%2F10%2F07%2Fselect%E5%92%8Cepoll%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[多路IO复用 传统IO使用 说明： 创建一个socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤 进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket 利用fread读取客户端socket当中的数据收到数据后服务器程序进行处理然后使用fwrite向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。 缺点： 一次只能处理一个连接，不支持多个连接同时处理 总结：一直等待着你的消息 预派生子进程模式 说明： 前面流程一致就不补充了 程序启动后就会创建N个进程。每个子进程进入Accept，等待新的连接进入。当客户端连接到服务器时，其中一个子进程会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当此连接关闭时，子进程会释放，重新进入Accept，参与处理新的连接。这个模型的优势是完全可以复用进程，不需要太多的上下文切换，比如php-fpm基于此模型的。 缺点： 这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。 例如：即时聊天程序，一台服务器可能要维持数十万的连接，那么就要启动数十万的进程来维持。这显然不可能 基于上面的模式我们发现我们只能通过每次（accept）处理单个请求，没办法一次性处理多个请求？ select,poll 单进程阻塞复用的网络服务器 说明： 服务监听流程如上 保存所有的socket,通过select系统调用，监听socket描述符的可读事件 Select会在内核空间监听一旦发现socket可读，会从内核空间传递至用户空间，在用户空间通过逻辑判断是服务端socket可读，还是客户端的socket可读 如果是服务端的socket可读，说明有新的客户端建立，将socket保留到监听数组当中 如果是客户端的socket可读，说明当前已经可以去读取客户端发送过来的内容了，读取内容，然后响应给客户端。 缺点： select模式本身的缺点（1、循环遍历处理事件、2、内核空间传递数据的消耗） 单进程对于大量任务处理乏力 总结一下，内核接管内容(仍然需要轮询)有变化然后返回过去，避免阻塞 监视并等待多个文件描述符的属性变化（可读、可写或错误异常）。select函数监视的文件描述符分 3 类，分别是writefds、readfds、和 exceptfds。调用后 select会阻塞，直到有描述符就绪（有数据可读、可写、或者有错误异常），或者超时（ timeout 指定等待时间），函数才返回。当 select()函数返回后，可以通过遍历 fdset，来找到就绪的描述符，并且描述符最大不能超过1024 poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 select/poll问题很明显，它们需要循环检测连接是否有事件。如果服务器有上百万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?php/** * Class Work1 * select复用模型 */class Work2&#123; public $onConnect; public $onMessage; public $socket; public $workNum = 4; public $read; public function __construct($path) &#123; //非阻塞监听 $this-&gt;socket = stream_socket_server($path); $this-&gt;read[(int)$this-&gt;socket] = $this-&gt;socket; stream_set_blocking($this-&gt;socket, 0); &#125; public function start() &#123; $this-&gt;fork(); &#125; public function fork() &#123; for ($i = 0; $i &lt; $this-&gt;workNum; $i++) &#123; $pid = pcntl_fork(); //创建成功会返回子进程id if ($pid &lt; 0) &#123; exit('创建失败'); &#125; else if ($pid &gt; 0) &#123; //父进程空间，返回子进程id &#125; else &#123; //返回为0子进程空间 $this-&gt;accept();//子进程负责接收客户端请求 &#125; &#125; //放在父进程空间，结束的子进程信息，阻塞状态 $status = 0; $pid = pcntl_wait($status); echo "子进程回收了:$pid" . PHP_EOL; &#125; public function accept() &#123; while (True) &#123; $write = $except = []; $read = $this-&gt;read; stream_select($read, $write, $except, 60); foreach ($read as $key =&gt; $val) &#123; if ($val === $this-&gt;socket) &#123; //触发connect事件 $client = stream_socket_accept($this-&gt;socket); $this-&gt;read[(int)$client] = $client; if (!empty($client) &amp;&amp; is_callable($this-&gt;onConnect)) &#123; call_user_func($this-&gt;onConnect, $client); &#125; &#125; else &#123; $buffer = fread($val, 65535); if (!$buffer)&#123; unset($this-&gt;read[(int)$val]); fclose($val); &#125; if (!empty($buffer) &amp;&amp; is_callable($this-&gt;onMessage)) &#123; call_user_func($this-&gt;onMessage, $val, $buffer); &#125; //没有断开回导致不得行 fclose($val); unset($this-&gt;read[(int)$val] ); &#125; &#125; &#125; &#125;&#125;$worker = new Work2("tcp://0.0.0.0:5000");$worker-&gt;onConnect = function ($fd) &#123; echo "有人来了" . (int)$fd . PHP_EOL;&#125;;$worker-&gt;onMessage = function ($fd, $data) &#123; $content = "你好！hello world!"; $http_resonse = "HTTP/1.1 200 OK\r\n"; $http_resonse .= "Content-Type: text/html;charset=UTF-8\r\n"; $http_resonse .= "Connection: keep-alive\r\n"; $http_resonse .= "Server: php socket server\r\n"; $http_resonse .= "Content-length: " . strlen($content) . "\r\n\r\n"; $http_resonse .= $content; fwrite($fd, $http_resonse);&#125;;$worker-&gt;start(); epollepoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制,无需轮询。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中。 简单点来说就是当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个进程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?php/** * Class Work1 * select复用模型 */class Work3&#123; public $onConnect; public $onMessage; public $socket; public $workNum = 4; public $read; public function __construct($path) &#123; //非阻塞监听 $this-&gt;socket = stream_socket_server($path); &#125; public function start() &#123; $this-&gt;accept(); &#125; public function fork() &#123; for ($i = 0; $i &lt; $this-&gt;workNum; $i++) &#123; $pid = pcntl_fork(); //创建成功会返回子进程id if ($pid &lt; 0) &#123; exit('创建失败'); &#125; else if ($pid &gt; 0) &#123; //父进程空间，返回子进程id &#125; else &#123; //返回为0子进程空间 $this-&gt;accept();//子进程负责接收客户端请求 &#125; &#125; //放在父进程空间，结束的子进程信息，阻塞状态 $status = 0; $pid = pcntl_wait($status); echo "子进程回收了:$pid" . PHP_EOL; &#125; public function accept() &#123; swoole_event_add($this-&gt;socket,function ($fd)&#123; $client = stream_socket_accept($this-&gt;socket); if (!empty($c) &amp;&amp; is_callable($this-&gt;onConnect)) &#123; call_user_func($this-&gt;onConnect, $fd); &#125; swoole_event_add($client,function ($c) use ($fd)&#123; $buffer = fread($c, 65535); if (!$buffer) &#123; fclose($c); &#125; if (!empty($buffer) &amp;&amp; is_callable($this-&gt;onMessage)) &#123; call_user_func($this-&gt;onMessage, $c, $buffer); &#125; //没有断开回导致不得行 fclose($c); &#125;); &#125;); &#125;&#125;$worker = new Work3("tcp://0.0.0.0:5000");$worker-&gt;onConnect = function ($fd) &#123; echo "有人来了" . (int)$fd . PHP_EOL;&#125;;$worker-&gt;onMessage = function ($fd, $data) &#123; $content = "你好！hello world!"; $http_resonse = "HTTP/1.1 200 OK\r\n"; $http_resonse .= "Content-Type: text/html;charset=UTF-8\r\n"; $http_resonse .= "Connection: keep-alive\r\n"; $http_resonse .= "Server: php socket server\r\n"; $http_resonse .= "Content-length: " . strlen($content) . "\r\n\r\n"; $http_resonse .= $content; fwrite($fd, $http_resonse);&#125;;$worker-&gt;start(); I/O流事件产生(可读事件的产生)，然后再处理(无需轮询)]]></content>
  </entry>
  <entry>
    <title><![CDATA[rpc服务注册简单实际应用模拟]]></title>
    <url>%2F2019%2F09%2F26%2Frpc%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%AE%80%E5%8D%95%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[在原有的基础上，我们将服务完善添加HttpServer 服务模式 RPC注册管理服务 管理注册中心和配置中心 CartService ShopService NameService 返回健康的服务地址 HttpServer服务 提供网页基础服务 内置rpc客户端，远程获取RPC服务中redis内容【可以直接省去】 再从rpc-client中获取最终健康服务地址 调用服务地址 Service 定时器：维持心跳 定时发送负载均衡信息 处理服务 流程分析 http服务 与其他服务器通信，在这之前需要从注册服务器中获取健康的服务地址详细代码 httpServer服务代码 1234567891011121314151617181920212223242526&lt;?phpclass Server&#123; protected $server; public function __construct($host,$port) &#123; $this-&gt;server = new \Swoole\Http\Server($host,$port); $this-&gt;server-&gt;on('request',[$this,'onRequest']); $this-&gt;server-&gt;start(); &#125; public function onRequest(\Swoole\Http\Request $request,\Swoole\Http\Response $response)&#123; $response-&gt;header('Content-Type','text/html'); //charset设置错误 $response-&gt;header('Charset','utf-8'); $header = $request-&gt;header; ob_start(); include "./index.php"; $res = ob_get_clean(); $response-&gt;end($res); &#125;&#125;new Server('0.0.0.0',5000); index.php 123456789101112131415161718192021&lt;?phpinclude_once "./RpcClient1.php";$client = new RpcClient1('127.0.0.1', 9801);?&gt;&lt;!doctype html&gt;&lt;html lang="ch"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;test服务&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; &lt;?php $client-&gt;service('CartService')-&gt;getList('aa'); ?&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; RpcClient 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass RpcClient1&#123; protected $client; public $data; protected $ip; protected $port; public function __construct($ip, $port) &#123; //连接数据库 $this-&gt;ip = $ip; $this-&gt;port = $port; //协议 $this-&gt;client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); &#125; public function service($name) &#123; //发送信息 $this-&gt;client-&gt;connect($this-&gt;ip, $this-&gt;port); $date = [ 'method' =&gt; 'get', 'name' =&gt; $name, ]; $this-&gt;client-&gt;send(json_encode($date,true)); $data = $this-&gt;client-&gt;recv(); $this-&gt;data = !empty($data) ? json_decode($data, true) : false; return $this; &#125; public function __call($name, $arguments) &#123; $data = [ 'action' =&gt; $name, 'argv' =&gt; $arguments, ]; var_dump($this-&gt;data, $data); &#125;&#125; Rpc 注册服务中心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?phpclass One&#123; public $server; public $table; public static $task_worker_num = 5; private $redis; protected $tcpServer; public function __construct($config) &#123; //新建server $server = new swoole_websocket_server('0.0.0.0', 9500); $this-&gt;server = $server; $server-&gt;set($config); //绑定server $this-&gt;server-&gt;on('Message', [$this, 'message']); $this-&gt;server-&gt;on('WorkerStart', [$this, 'workerStart']); $this-&gt;server-&gt;on('close', [$this, 'close']); $this-&gt;server-&gt;on('receive', [$this, 'onReceive']); $this-&gt;tcpServer = $this-&gt;server-&gt;addlistener('0.0.0.0', '9801', SWOOLE_TCP);// $server-&gt;on('receive', [$this, 'onReceive']); $this-&gt;tcpServer-&gt;set([ 'worker_num' =&gt; 3, 'package_max_length' =&gt; 1024 * 1024 * 10, 'max_request' =&gt; 3000, ]); $this-&gt;server-&gt;start(); &#125; public function onReceive($serv, $fd, $reactor_id, $data) &#123; var_dump($data); $data = json_decode($data, true); if ($data) &#123; var_dump($data); if ($data['method'] == 'get') &#123; //获取服务 $service_key = 'service:' . $data['name']; $res = $this-&gt;redis-&gt;sMembers($service_key); var_dump($res); if (empty($res)) &#123; $serv-&gt;send($fd, ''); &#125; $serv-&gt;send($fd, json_encode($res)); &#125; &#125; &#125; public function message($serv, $fd) &#123; //注册 if ($data = json_decode($fd-&gt;data, true)) &#123; //判断是否是注册 var_dump($data); if ($data['method'] == 'register') &#123; $service_key = 'service:' . $data['name']; //echo $service_key; $value = json_encode([ 'ip' =&gt; $data['ip'], 'port' =&gt; $data['port'], ]); var_dump($service_key, $value); $this-&gt;redis-&gt;sRem($service_key, $value); $res = $this-&gt;redis-&gt;sAdd($service_key, $value); //swoole_table $redis = $this-&gt;redis; //利用定时器,检测代码服务端的存活状态 if ($res) &#123; $serv-&gt;tick(3000, function ($id) use ($serv, $service_key, $value, $redis, $fd) &#123; //不是存活的状态下 if (!$serv-&gt;exist($fd-&gt;fd)) &#123; //检测服务在不在redis当中,如果在就移除这个服务 if ($redis-&gt;SISMEMBER($service_key, $value)) &#123; //只是移除,如果需要可以更新状态 $redis-&gt;sRem($service_key, $value); &#125; //获取集合当中的成员 var_dump($redis-&gt;sMembers($service_key)); //清除定时器 $serv-&gt;clearTimer($id); &#125; &#125;); &#125; &#125; else if ($data['method'] == 'get') &#123; //获取服务 $service_key = 'service:' . $data['name']; $res = $this-&gt;redis-&gt;sMembers($service_key); if (empty($res)) &#123; $this-&gt;server-&gt;push($fd-&gt;fd, ''); &#125; $this-&gt;server-&gt;push($fd-&gt;fd, json_encode($res)); &#125; &#125; &#125; public function workerStart($serv, $fd) &#123; //连接redis $this-&gt;redis = new \Redis(); $this-&gt;redis-&gt;connect('127.0.0.1', '6379'); &#125; public function close($serv, $fd) &#123; //连接redis &#125;&#125;$config = [ 'worker_num' =&gt; 4, //worker process num 'max_request' =&gt; 3000, 'heartbeat_idle_time' =&gt; 5,//连接最大的空闲时间 'heartbeat_check_interval' =&gt; 2 //定时检测在线列表];new One($config);]]></content>
      <categories>
        <category>学习</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>swoole</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探RPC分布式服务模式——swoole]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%88%9D%E6%8E%A2RPC%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94swoole%2F</url>
    <content type="text"><![CDATA[通过swoole多监听的方式创建服务注册中心，通过模拟其他服务器进行注册。 RPC Rpc是什么？ RPC全称为Remote Procedure Call，翻译过来为“远程过程调用”。目前，主流的平台中都支持各种远程调用技术，以满足分布式系统架构中不同的系统之间的远程通信和相互调用，也是实现微服务当中的重要的环节。 客户端通过发送一个规定的rpc协议，请求服务的注册中心，由服务注册中心检索可用服务，并且实现调用转发，服务内容由代码服务器在启动的时候，注册到服务中心。服务中心暂时利用redis存储内容。 服务架构图 服务中心 通过redis中的集合存储服务注册的内容 心跳维持，健康检查 定期检测服务器的健康，如果服务器宕机，从服务列表当中删除 多端口协议混合监听接收rpc服务调用 协议的统一转换 服务端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpclass One&#123; public $server; public $table; public static $task_worker_num = 5; private $redis; public function __construct($config) &#123; //新建server $server = new swoole_websocket_server('0.0.0.0', 9500); $server-&gt;set($config); //绑定server $server-&gt;on('Message', [$this, 'message']); $server-&gt;on('WorkerStart', [$this, 'workerStart']); $server-&gt;on('close', [$this, 'close']); $server-&gt;start(); &#125; public function message($serv, $fd) &#123; //注册 if ($data = json_decode($fd-&gt;data, true)) &#123; //判断是否是注册 if ($data['method'] == 'register') &#123; $service_key='service'; //echo $service_key; var_dump($service_key); $value=json_encode([ 'name'=&gt;$data['name'], 'ip'=&gt;$data['ip'], 'port'=&gt;$data['port'], ]); $res=$this-&gt;redis-&gt;sAdd($service_key,$value); //swoole_table $redis=$this-&gt;redis; //利用定时器,检测代码服务端的存活状态 if($res)&#123; $serv-&gt;tick(3000,function ($id) use($serv,$service_key,$value,$redis,$fd)&#123; //不是存活的状态下 if(!$serv-&gt;exist($fd-&gt;fd))&#123; //检测服务在不在redis当中,如果在就移除这个服务 if($redis-&gt;SISMEMBER($service_key,$value))&#123; //只是移除,如果需要可以更新状态 $redis-&gt;sRem($service_key,$value); &#125; //获取集合当中的成员 var_dump($redis-&gt;sMembers($service_key)); //清除定时器 $serv-&gt;clearTimer($id); &#125; &#125;); &#125; &#125; &#125; &#125; public function workerStart($serv, $fd) &#123; //连接redis $this-&gt;redis = new \Redis(); $this-&gt;redis-&gt;connect('127.0.0.1', '6379'); &#125; public function close($serv, $fd) &#123; //连接redis &#125;&#125;$config = [ 'worker_num' =&gt; 4, //worker process num 'max_request' =&gt; 3000, 'heartbeat_idle_time' =&gt; 5,//连接最大的空闲时间 'heartbeat_check_interval' =&gt; 2 //定时检测在线列表];new One($config); 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpuse client\Client\Client;class Service01&#123; private $data; public $server; public $table; public function __construct($config, $data) &#123; //新建server $this-&gt;data = $data; $server = new swoole_websocket_server($config['host'],$config['port']); $server-&gt;set($config); //绑定server $server-&gt;on('WorkerStart', [$this, 'WorkerStart']); $server-&gt;on('Message', [$this, 'Message']); $server-&gt;start(); &#125; public function WorkerStart($serv, $fd) &#123; echo "启动$fd" . PHP_EOL; if ($fd === 0) &#123; //注册服务 include dirname(__DIR__) . "/client/Client.php"; $client = new Client("127.0.0.1", 9500); //需要发送的消息 $data = $this-&gt;data; $cli = $client-&gt;asyn_websocket(); $cli-&gt;push(json_encode($data)); //定时发送 Swoole\Timer::tick(200, function () use ($cli) &#123; $cli-&gt;push('', 9); &#125;); &#125; &#125; public function Message($serv, $fd, $rd, $data) &#123; &#125;&#125;$config = array( 'worker_num' =&gt; 4, //worker process num 'host'=&gt;'0.0.0.0', 'port'=&gt;9501);$data = [ 'method' =&gt; 'register', 'name' =&gt; 'CartService', 'ip' =&gt; '127.0.0.1', 'port' =&gt; 9501];new Service01($config, $data); Tools =&gt; 简单版的连接工具类 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace client\Client;/** * Class Client * @package client\Client * 连接客户端 */class Client&#123; protected $host; protected $port; protected $client; public function __construct($host, $port) &#123; $this-&gt;host = $host; $this-&gt;port = $port; &#125; /** * @param string $path * @return \Swoole\Coroutine\Http\Client */ public function asyn_websocket( $path = '/') &#123; $this-&gt;client=new \Swoole\Coroutine\Http\Client($this-&gt;host,$this-&gt;port); //升级未长连接 $this-&gt;client-&gt;upgrade($path); return $this-&gt;client; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>swoole</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学思维]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[计算机科学家思维 什么是计算机相关? 未找到答案 知识分为哪两种 declarative陈述性 一个事实性的陈述imprerative程序性 对推论过程的描述演变过程固定程序计算机差分机: 手动转动齿轮完成四则运算 例如计算器:只能完成特定的计算ALU分析指令集进行计算编程是什么? 一堆原料根据不同的食谱可以演变成为不同的菜 当然与不同的厨师，不同的厨具也能产生不同的 类比一下=&gt; 不同的数据类型结合一起也能产生不同的程序 爱兰图灵说：用六种基本数据类型就可以表达整个世界 图灵兼容性：你能在这个语言中实现的东西， 自然也能在另一个语言中实现[用php写一个爬虫框架!!] 编译型语言 能够提前预知到错误 解释型语言 运行过程中才能发现 语法 语义的区分 python语义 cat dog boy Static 语义 My clothes is red full 语义 What i want to do]]></content>
  </entry>
  <entry>
    <title><![CDATA[go基础学习]]></title>
    <url>%2F2019%2F09%2F22%2Fgo%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[go数据类型基础数据类型 字符型 浮点型 整型 字符串 派生/数据类型 指针 数组 结构体 管道 函数 切口 接口 map 12345678910111213141516171819 var a1 int; fmt.Println("a1 = ",a1,unsafe.Alignof(a1)) var a2 float32; fmt.Println("a2 = ",a2,unsafe.Alignof(a2)) var a3 float64; fmt.Println("a3 = ",a3,unsafe.Alignof(a3)) var a4 string; fmt.Println("a4 = ",a4,unsafe.Alignof(a4)) var a5 byte; fmt.Println("a5 = ",a5,unsafe.Alignof(a5)) var a6 bool; fmt.Println("a6 = ",a6,unsafe.Alignof(a6)) //a1 = 0 8//a2 = 0 4//a3 = 0 8//a4 = 8//a5 = 0 1//a6 = false 1 变量声明 传统定义方式 定义加赋值的两种方式 123456789101112131415161718192021222324252627package mainimport ( "fmt" "time")func main() &#123; var n int; n = 1; //默认值 var m int var o = "aa" p:="dd" fmt.Print("hello world") time.Sleep(3*time.Second) fmt.Println("hello world",n,m,o,p) //多变量方式1 var a,b,c int; fmt.Println("a",a,b,c) //方式2 var e,f,g = "a",1,2 fmt.Println("a",e,f,g) //方式3 u,v,w:= 1,2,3 fmt.Println("a",u,v,w)&#125; 注意事项 必须以go为后缀 严格区分大小写 go应用程序执行入口是main go语言每条语句不需要加; go语言一行内最好别出现多条语句 go中import但未使用的包和未使用的变量会导致编译未通过]]></content>
      <tags>
        <tag>go</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础学习——发展历史以及基础概念]]></title>
    <url>%2F2019%2F09%2F22%2Fjava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[用于及时复习java基础知识 java基础是学习大数据 J2EE Android 开发的基石！！ 12345Graphical User Interface (GUI) --&gt; 图形化界面 Command User Inteerface (CLI) --&gt; 命令行界面 后端开发语言:java php python go node.js java发展历史 1991 年 Green 项目 最初名称为 Oak橡树 1996 年发布jdk 1.0 2004年发布里程碑式版本 1.5 为突出该版本的和重要性,后更名为jdk5.0 2008年发布jdk8.0 =&gt; 1.8 是继jdk5.0版本变化最大的一个版本 2018年发布jdk 10.0 [jdk1.8.3] 等等 java技术平台体系 企业级应用 Android开发 大数据平台开发 java特点 java 中舍弃 C语言中容易引起错误的指针， 增加了gc垃圾回收机制 面向对象 面向对象三大特性: 继承，多态，封 健壮性 吸引了c, c++ 语言的特性 跨平台性 -只要安装了 java虚拟机，即可运行java软件 java 基础语法 main 函数 123456class A &#123; public static void main(String args[])&#123; &#125;&#125; 数据类型//todo 面向对象//todo]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>stduy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日单词笔记]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%AF%8F%E6%97%A5%E5%8D%95%E8%AF%8D%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[9.19 constitution 宪法 sencus 人口普查 conducted 进行 distributing 分布 federal 联邦的 purpose 目的 funds 基金 good stuff like that 像这样的好东西 booming蓬勃发展 compile 编译 predicted 预测 compute 计算 9.20 scale 规模 increase 增加 9.21 episode 插曲 symbol 符号 components 组成成分 9.22 freshman 大一新生 recipes 方法 general 通常]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>stduy</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel-admin在laravel-admin下运行——记一次因为莽付出的代价]]></title>
    <url>%2F2019%2F09%2F22%2Flaravel-admin%E5%9C%A8laravel-admin%E4%B8%8B%E8%BF%90%E8%A1%8C%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%A0%E4%B8%BA%E8%8E%BD%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[初生牛犊不怕虎,直接莽上laravels 前因 我们公司一直都是采用 think3.2 ，虽然使用起来确实不错,但是哪能有 laravel 舒服 于是我才用 laravel ，但是经理觉得后台太慢了 我做了一部分优化还是慢，我太难了，之前他让我随便选框架 我就想到了大佬的 [laravels](https://github.com/hhxsv5/laravel-s) 心里想laravels+laravel-admin岂不是美哉，毕竟有swoole `以前学过一些，觉得应该可以把持住` 结果一使用出大问题 发现问题，问题介绍 第一个问题就是比较常见的，顶部的刷新无限增多，如图 第二个问题就是，删除这个却进入上一个进入的删除路由，导致各种删除失败 导出excel提示exit 4.Pjax中间件提示exit 目前比较真实的问题就是这么一些，具体其他问题请等待我后续的发现 解决问题，提供思路 授人以鱼不如授人以渔 我们先排查第一个问题，这个比较常见，其实就是我们的Admin实例并没有被清除，导致无限添加navBar 然后在 admin/bootstrap.php中每次都调用一下 于是我想到第一个办法，这个方法比较 憨批 ，因为当时认为这个实例重新创建应该挺麻烦，所以采用局部清理的方式 解决问题之后测试删除功能，又发现新的问题，也就是问题2 这个问题很明显是实例没清理干净，导致上一步生成的js下一步仍然存在，排除在控制器生成的可能，所以初步判断只有可能存在于\Encore\Admin\Admin实例中，因为这个实例是存在于容器中所以直接从中寻找，发现原来是\Encore\Admin\Admin静态变量 12345678910111213141516171819202122//因为是表单所以我们先进入 Encore\Admin\Form\Form 寻找Tool 发现renderDelete protected function renderDelete() &#123; $trans = [ 'delete_confirm' =&gt; trans('admin.delete_confirm'), 'confirm' =&gt; trans('admin.confirm'), 'cancel' =&gt; trans('admin.cancel'), 'delete' =&gt; trans('admin.delete'), ]; . . . Admin::script($script); return &lt;&lt;&lt;HTML&lt;div class="btn-group pull-right" style="margin-right: 5px"&gt; &lt;a href="javascript:void(0);" class="btn btn-sm btn-danger &#123;$class&#125;-delete" title="&#123;$trans['delete']&#125;"&gt; &lt;i class="fa fa-trash"&gt;&lt;/i&gt;&lt;span class="hidden-xs"&gt; &#123;$trans['delete']&#125;&lt;/span&gt; &lt;/a&gt;\&lt;/div&gt;HTML; &#125; 看到核心 Admin::script 这个原来是在Admin 下的 HasAssets， 123456789101112131415161718/** * @param string $script * @param bool $deferred * @return array|\Illuminate\Contracts\View\Factory|\Illuminate\View\View */ public static function script($script = '', $deferred = false)&#123; if (!empty($script)) &#123; if ($deferred) &#123; return self::$deferredScript = array_merge(self::$deferredScript, (array) $script); &#125; return self::$script = array_merge(self::$script, (array) $script); &#125; $script = array_unique(array_merge(static::$script, static::$deferredScript)); return view('admin::partials.script', compact('script'));&#125; 那么解决起来就狠方便了 直接在bootstrap中初始化一下这些静态变量即可 我觉得麻烦所以就直接写了一个clean，之前憨批的方法我也就换成更加粗暴的方式，最终还是清理掉Admin在容器中的实例 12345678910 \Encore\Admin\Admin::$script=[]; \Encore\Admin\Admin::$deferredScript=[]; \Encore\Admin\Admin::$headerJs = []; \Encore\Admin\Admin::$manifestData = []; \Encore\Admin\Admin::$extensions = [];... $app-&gt;forgetInstance(\Encore\Admin\Admin::class); Facade::clearResolvedInstance(\Encore\Admin\Admin::class); 由此，问题一和问题二已经基本解决，菜鸟也想学习大佬的操作，想要更加优雅一点 下面就是解决exit问题了，中间复杂心里斗争，最后只能采用抛出异常的方式 Pjax中的exit 在56行 Export中 这里就很多，我就不一一指出 12345678910111213141516171819202122232425262728293031323334 //导出操作 $res = Response::stream(function () &#123; $handle = fopen('php://output', 'w'); $titles = []; $this-&gt;chunk(function ($records) use ($handle, &amp;$titles) &#123; if (empty($titles)) &#123; $titles = $this-&gt;getHeaderRowFromRecords($records); // Add CSV headers fputcsv($handle, $titles); &#125; foreach ($records as $record) &#123; fputcsv($handle, $this-&gt;getFormattedRecord($record)); &#125; &#125;); // Close the output stream fclose($handle); &#125;, 200, $headers); swoole_exit($res);//Pjax 修改后 $next = function () use ($response) &#123; return $response; &#125;; swoole_exit((new static())-&gt;handle(Request::capture(), $next)); //swoole_exit神秘面纱if (!function_exists('swoole_exit'))&#123; function swoole_exit($response) &#123; throw new App\Exceptions\SwooleExitException($response); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //修改Handler &lt;?phpnamespace App\Exceptions;use Exception;use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;use Illuminate\Routing\Router;use Illuminate\Support\Facades\Response;use Symfony\Component\HttpFoundation\Response as SymfonyResponse;class Handler extends ExceptionHandler\&#123; /** * A list of the exception types that are not reported.\ *\ * @var array */ protected $dontReport = [ SwooleExitException::class ]; /** * A list of the inputs that are never flashed for validation exceptions.\ *\ * @var array */ protected $dontFlash = [ 'password', 'password_confirmation', ]; /** * Report or log an exception@param \Exception $exception\ * @return void\ */ public function report(Exception $exception) &#123; parent::report($exception); &#125; /** * Render an exception into an HTTP response.\ *\ * @param \Illuminate\Http\Request $request * @param \Exception $exception * @return \Illuminate\Http\Response */ public function render($request, Exception $exception) &#123; //判断是否为我们的自定义异常 if ($exception instanceof SwooleExitException) &#123; //直接调用perpare return $exception-&gt;getResponse()-&gt;prepare($request); &#125; return parent::render($request, $exception); &#125;&#125; 12345678910111213141516171819&lt;?phpnamespace App\Exceptions;use Exception;use Throwable;class SwooleExitException extends Exception\&#123; protected $response; public function __construct($response,$message = "", $code = 0, Throwable $previous = null) &#123; $this-&gt;response = $response; parent::__construct($message, $code, $previous); &#125;//获取响应内容public function getResponse()&#123; return $this-&gt;response;&#125; 如果你直接把exit去掉，那么 导出csv 会提示你 oops … ob_end_clean() 这个报错 我们可以在Hhxsv5\LaravelS\Illuminate\Laravel中的 handleDynamic 加一个判断ob_get_length()也可以不加，因为后期解决exit退出问题，也就不会有这种报错 解决思路因为exit其实就是不执行后续的响应 ，所以我们想到异常就是执行到异常抛出之前，于是我们可以定义一种特定的异常，来提前结束，用来代替exit ，至于 swoole/laravels 为什么不能使用这些函数我就不在这赘述 使用异常，但是我们也得返回请求，但是我们的请求不能直接send掉，因为laravels需要使用swoole的方式返回，我们直接执行 send 是不起作用的，那我们就可以通过特定的异常返回我们所需要的响应， 123456789101112131415161718192021222324public static function toResponse($request, $response)\&#123; if ($response instanceof Responsable) &#123; $response = $response-&gt;toResponse($request); &#125; if ($response instanceof PsrResponseInterface) &#123; $response = (new HttpFoundationFactory)-&gt;createResponse($response); &#125; elseif ($response instanceof Model &amp;&amp; $response-&gt;wasRecentlyCreated) &#123; $response = new JsonResponse($response, 201); &#125; elseif (! $response instanceof SymfonyResponse &amp;&amp; ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || is_array($response))) &#123; $response = new JsonResponse($response); &#125; elseif (! $response instanceof SymfonyResponse) &#123; $response = new Response($response); &#125; if ($response-&gt;getStatusCode() === Response::HTTP_NOT_MODIFIED) &#123; $response-&gt;setNotModified(); &#125; return $response-&gt;prepare($request);&#125; 替换Router::toResponse(); 为 $exception-&gt;prepare() 无需其他中间过程 1由于使用过程中发现toResponse()导出多次会发现异常问题，所以替换，具体原因还在查找中 感谢z-song提供的laravel-admin优质扩展 感谢hhxsv5提供的laravel-s优质扩展 具体分析请等下次更新，我们把laravels大致走一遍，学习一下 laravels可以获取到最终响应然后返回，目的就达到了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>laravel</tag>
        <tag>laravels</tag>
        <tag>laravel-admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%85%B3%E4%BA%8E%2F</url>
    <content type="text"><![CDATA[简单介绍一下本站 网站简介 本网站用来记录生活,学习,技术,等等 作者QQ:1136589038]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tp 3.2 运行分析 1 初步认识篇]]></title>
    <url>%2F2019%2F09%2F22%2FTp-3-2-%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[初步介绍thinkphp的运行模式以及基本流程 think 3.2 文件逐层进入让我们一起进入thinkphp的设计方式 看看3.2性能为什么那么强大[仅仅一部分] - 路由等非常迅速 - 但是遇到数据库操作[关联关系n+1问题] 有什么可取之处 又有什么需要避免的地方 优点： tp3.2与ssh非常相似 所以采用java的开发思路去开发tp是非常舒服的 还有诸多可以优化的地方 --&gt; 1.优化框架n+1问题 --&gt; 2.解决一些其他耗时性能问题 使得框架更有利于快速开发 本次实践 发现虽然很多轮子都需要手动找或者自己做 但是,解决了一些很久以前没使用过的底层问题 注重过程 缺点： 但是tp3.2 我认为性能并不是特别的强势 [很多地方仍然可以优化]入口文件 index.php 定义一些基础-&gt;引入引导文件 12345678// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为falsedefine('APP_DEBUG',True);//默认模块define('BIND_MODULE','Home');//应用目录define('APP_PATH','./Application/');//引入核心文件require "./ThinkPHP/ThinkPHP.php"; 引导运行文件 ThinkPHP.php入口文件解析 1234567891011121314151617181920212223242526272829303132333435363738// 记录开始运行时间$GLOBALS['_beginTime'] = microtime(TRUE);if(!IS_CLI) &#123; // 当前文件名 if(!defined('_PHP_FILE_')) &#123; if(IS_CGI) &#123; //CGI/FASTCGI模式下 $_temp = explode('.php',$_SERVER['PHP_SELF']); define('_PHP_FILE_', rtrim(str_replace($_SERVER['HTTP_HOST'],'',$_temp[0].'.php'),'/')); &#125;else &#123; define('_PHP_FILE_', rtrim($_SERVER['SCRIPT_NAME'],'/')); &#125; &#125; if(!defined('__ROOT__')) &#123; $_root = rtrim(dirname(_PHP_FILE_),'/'); define('__ROOT__', (($_root=='/' || $_root=='\\')?'':$_root)); &#125;&#125;// 加载核心Think类 // CORE_PATH ==&gt; Library/Think/Think.vlass.phprequire CORE_PATH.'Think'.EXT;//开始引导运行Think\Think::start(); Think 核心类 Think.class.php 引导结构 性能缺点分析todo解耦合todo]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinkphp</tag>
        <tag>php</tag>
        <tag>framework</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
</search>
